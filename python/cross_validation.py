"""
Copyright (C) 2019-2020 Emanuele Paci, Simon P. Skinner, Michele Stofella

This program is free software: you can redistribute it and/or modify
it under the terms of version 2 of the GNU General Public License as published
by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

from exPfact import run
from read import read_assignments, \
                 read_seq, \
                 read_dexp, \
                 read_pfact, \
                 read_configuration
from calc_dpred import calculate_dpred
from kint import calculate_kint_for_sequence
from logger import log
import numpy as np
import os
import argparse
import sys

lambdas = np.logspace(-15, -1, 15, endpoint=True)


def loo_dataset(dexp, time_points, k):
    """
    This function splits the experimental dataset composed by N time points
    and M peptides into a training dataset composed by all N time points
    except the k-th index (1<=k<=N) and a test dataset composed
    by the remaining time point.
    """
    dexp_train = np.array([np.delete(dexp[j], k) for j in range(len(dexp))])
    times_train = np.delete(time_points, k)
    dexp_test = np.array([dexp[j][k] for j in range(len(dexp))])
    times_test = np.array([time_points[k]])
    return dexp_train, times_train, dexp_test, times_test


def loo_crossval(dexp, time_points, ass, lam, pH, temp, seq, res1, resn):
    """
    This function performs leave-one-out cross-validation at a fixed value
    of lambda. All protecion factors are initialized to ln(P)=1
    (except prolines, for which ln(P)=-1). A minimization is applied using
    a specific penalization term lambda. The cross validation error is
    evaluated on every train and test datasets generated by leaving out
    one time point at a time.
    """
    cv_train = 0
    cv_test = 0
    for k in range(len(time_points)):

        out_file = "CVout.rm%s" % str(k)

        dexp_train, times_train, dexp_test, times_test = L1OUT_dataset(dexp, time_points, k)

        run(base_dir=os.getcwd(), dexp=dexp_train, assignments=ass, pfact=None,
            random_steps=None, time_points=times_train, harmonic_term=lam,
            output_file=out_file, tolerance=1e-10, weights=None,
            pH=pH, temperature=temp, seq=seq, res1=res1, resn=resn)

        pfact = read_pfact(out_file+'.pfact')
        dpred_test = calculate_dpred(pfact, times_test, kint, ass)
        cost_test = [1 / len(pred) * np.sum((pred - exp)**2) for pred, exp in zip(dpred_test, dexp_test)]

        cv_train += sum(np.loadtxt(out_file+'.diff'))[1]  # summed over peptides
        cv_test += sum(cost_test)  # sum over peptides

        os.remove(out_file+".Dpred")
        os.remove(out_file+".diff")
        os.remove(out_file+".pfact")
    return cv_train / len(time_points), cv_test / len(time_points)


def cross_validate(dexp, time_points, ass, lambdas, pH, temp, seq, res1, resn):
    """
    This function applies leave-one-out cross-validation to a dataset at
    varying values of the penalty term lambda. The values for lambda
    are fixed (line 21) and cover 10 orders of magnitude.
    For each value of lambda, the function L1OUT_crossval is applied.
    """
    fout = open('CVtest2.res', 'w+')
    for i in range(len(lambdas)):
        log.info("Calculating at lambda=%5.10f" % round(lambdas[i]))
        CVtrain, CVtest = loo_crossval(dexp, time_points, ass, lambdas[i],
                                         pH, temp, seq, res1, resn)
        fout.write('{} {} {}\n'.format(lambdas[i], CVtrain, CVtest))
    fout.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument("--dexp")
    parser.add_argument("--ass")
    parser.add_argument("--temp")
    parser.add_argument("--pH")
    parser.add_argument("--seq")

    if sys.argv[1].endswith('.json'):
        config = read_configuration(sys.argv[1])
    else:
        config = {}
        opts = parser.parse_args()

        # Compulsory arguments
        if opts.dexp:
            dexp, time_points = read_dexp(opts.dexp)
        if opts.ass:
            ass = read_assignments(opts.ass)
        if opts.temp:
            temp = float(opts.temp)
        if opts.pH:
            pH = float(opts.pH)
        if opts.seq:
            seq = read_seq(opts.seq)
            res1 = 1
            resn = len(read_seq(opts.seq))

    log.info("Running cross_validation.py")
    kint, prolines = calculate_kint_for_sequence(res1, resn, seq, temp, pH)
    cross_validate(dexp, time_points, ass, lambdas, pH, temp, seq, res1, resn)
